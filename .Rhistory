library(rmeta)
?smoteMatch
source('D:/work/github/rmeta-master/R/modelMeta.R', echo=TRUE)
########### model for metagenome ############
#' smote.exs2
#' this function from package DMwR smote.exs
#' @param data
#' @param tgt
#' @param N
#' @param k
#'
#' @return
#' @export
#'
#' @examples
smote.exs2 <- function(data,tgt,N,k)
# INPUTS:
# data are the rare cases (the minority "class" cases)
# tgt is the name of the target variable
# N is the percentage of over-sampling to carry out;
# and k is the number of nearest neighours to use for the generation
# OUTPUTS:
# The result of the function is a (N/100)*T set of generated
# examples with rare values on the target
{
nomatr <- c()
T <- matrix(nrow=dim(data)[1],ncol=dim(data)[2]-1)
for(col in seq.int(dim(T)[2]))
if (class(data[,col]) %in% c('factor','character')) {
T[,col] <- as.integer(data[,col])
nomatr <- c(nomatr,col)
} else T[,col] <- data[,col]
if (N < 100) { # only a percentage of the T cases will be SMOTEd
nT <- NROW(T)
idx <- sample(1:nT,as.integer((N/100)*nT))
T <- T[idx,]
N <- 100
}
p <- dim(T)[2]
nT <- dim(T)[1]
ranges <- apply(T,2,max)-apply(T,2,min)
nexs <-  as.integer(N/100) # this is the number of artificial exs generated
# for each member of T
new <- matrix(nrow=nexs*nT,ncol=p)    # the new cases
for(i in 1:nT) {
# the k NNs of case T[i,]
xd <- scale(T,T[i,],ranges)
for(a in nomatr) xd[,a] <- xd[,a]==0
dd <- drop(xd^2 %*% rep(1, ncol(xd)))
kNNs <- order(dd)[2:(k+1)]
for(n in 1:nexs) {
# select randomly one of the k NNs
neig <- sample(1:k,1)
ex <- vector(length=ncol(T))
# the attribute values of the generated case
difs <- T[kNNs[neig],]-T[i,]
new[(i-1)*nexs+n,] <- T[i,]+runif(1)*difs
for(a in nomatr)
new[(i-1)*nexs+n,a] <- c(T[kNNs[neig],a],T[i,a])[1+round(runif(1),0)]
}
}
newCases <- data.frame(new)
for(a in nomatr)
newCases[,a] <- factor(newCases[,a],levels=1:nlevels(data[,a]),labels=levels(data[,a]))
newCases[,tgt] <- factor(rep(data[1,tgt],nrow(newCases)),levels=levels(data[,tgt]))
colnames(newCases) <- colnames(data)
newCases
}
#' rmetaSMOTE
#'
#' @param form
#' @param data
#' @param perc.over
#' @param k
#' @param learner
#' @param ...
#'
#' @return
#' @export
#'
#' @examples
rmetaSMOTE <- function(form,data,
perc.over=200,k=5,
#perc.under=200,
learner=NULL,...
){
# INPUTS:
# form a model formula
# data the original training set (with the unbalanced distribution)
# minCl  the minority class label
# per.over/100 is the number of new cases (smoted cases) generated
#              for each rare case. If perc.over < 100 a single case
#              is generated uniquely for a randomly selected perc.over
#              of the rare cases
# k is the number of neighbours to consider as the pool from where
#   the new examples are generated
# perc.under/100 is the number of "normal" cases that are randomly
#                selected for each smoted case
# learner the learning system to use.
# ...  any learning parameters to pass to learner
# the column where the target variable is
tgt <- which(names(data) == as.character(form[[2]]))
minCl <- levels(data[,tgt])[which.min(table(data[,tgt]))]
# get the cases of the minority class
minExs <- which(data[,tgt] == minCl)
# generate synthetic cases from these minExs
if (tgt < ncol(data)) {
cols <- 1:ncol(data)
cols[c(tgt,ncol(data))] <- cols[c(ncol(data),tgt)]
data <-  data[,cols]
}
newExs <- smote.exs2(data[minExs,],ncol(data),perc.over,k)
if (tgt < ncol(data)) {
newExs <- newExs[,cols]
data <- data[,cols]
}
# get the undersample of the "majority class" examples
# selMaj <- sample((1:NROW(data))[-minExs],
#                 as.integer((perc.under/100)*nrow(newExs)),
#                 replace=T)
selMaj <- (1:NROW(data))[-minExs]
# the final data set (the undersample+the rare cases+the smoted exs)
newdataset <- rbind(data[selMaj,],data[minExs,],newExs)
# learn a model if required
if (is.null(learner)) return(newdataset)
else do.call(learner,list(form,newdataset,...))
}
#' smoteMatch
#'
#' @param data
#' @param group
#'
#' @return
#' @export
#'
#' @examples
smoteMatch <- function(data, group){
# match the sample id
#library(DMwR)
id <- intersect(rownames(data), rownames(group))
dataX <- data[id, ]
dataY <- group[id, , drop=F]
# to get the SMOTE function parameter perc.over , perc.under
less <- min(table(dataY[,1]))
over <- max(table(dataY[,1]))
perc.over <- ((over/less)-1)*100
#perc.under <- over*100*100/(less*perc.over)
# generate the new data
data$group <- group[,1]
newData <- rmetaSMOTE(group ~ ., data, perc.over = perc.over)
return(newData)
}
newData <- rmetaSMOTE(Species ~ ., data_tmp, perc.over = 150)
newData
table(newData$Species)
library(rmeta)
paste0(c("a", "b"), "_", 1:2)
checkOutlier <- function(x, coef = 2, sname ,plot = F, vname = "test"){
# whether is a conituous data
if(is.numeric(x) & length(levels(as.factor(x)))>=5){
# get the outlier index
x[is.na(x)] <- median(x, na.rm = T)
quantiles <- quantile(x, probs=c(0.25,0.75), na.rm = T)
IQR <- quantiles[2]-quantiles[1]
index <- x < (quantiles[1]-coef*IQR)|x > (quantiles[2]+coef*IQR)
# print the outlier
name <- paste0(sname[index], "_", round(x[index], 2))
res <-  paste(name, collapse = " ")
return(res)
# print the outlier sample on boxplot
if(plot){
data <- data.frame(value = x)
dat$label <- ifelse(index, sname, "")
dat$var <- rep(vname, nrow(dat))
ggplot(dat,aes(var,value))+
geom_boxplot()+geom_text(aes(label=label),hjust=-0.1)
}
}else{
stop("the value is not conituous data\n")
}
}
checkOutlier(c(1:10,30), sname = paste0("a",1:11))
checkOutlier(c(1:10,30), sname = paste0("a",1:11), plot = T)
checkOutlier(c(1:10,30), sname = paste0("a",1:11), plot = TRUE)
checkOutlier <- function(x, coef = 2, sname ,plot = F, vname = "test"){
# whether is a conituous data
if(is.numeric(x) & length(levels(as.factor(x)))>=5){
# get the outlier index
x[is.na(x)] <- median(x, na.rm = T)
quantiles <- quantile(x, probs=c(0.25,0.75), na.rm = T)
IQR <- quantiles[2]-quantiles[1]
index <- x < (quantiles[1]-coef*IQR)|x > (quantiles[2]+coef*IQR)
# print the outlier
name <- paste0(sname[index], "_", round(x[index], 2))
res <-  paste(name, collapse = " ")
#return(res)
# print the outlier sample on boxplot
if(plot){
data <- data.frame(value = x)
dat$label <- ifelse(index, sname, "")
dat$var <- rep(vname, nrow(dat))
ggplot(dat,aes(var,value))+
geom_boxplot()+geom_text(aes(label=label),hjust=-0.1)
}
return(res)
}else{
stop("the value is not conituous data\n")
}
}
checkOutlier(c(1:10,30), sname = paste0("a",1:11), plot = TRUE)
checkOutlier <- function(x, coef = 2, sname ,plot = F, vname = "test"){
# whether is a conituous data
if(is.numeric(x) & length(levels(as.factor(x)))>=5){
# get the outlier index
x[is.na(x)] <- median(x, na.rm = T)
quantiles <- quantile(x, probs=c(0.25,0.75), na.rm = T)
IQR <- quantiles[2]-quantiles[1]
index <- x < (quantiles[1]-coef*IQR)|x > (quantiles[2]+coef*IQR)
# print the outlier
name <- paste0(sname[index], "_", round(x[index], 2))
res <-  paste(name, collapse = " ")
#return(res)
# print the outlier sample on boxplot
if(plot){
dat <- data.frame(value = x)
dat$label <- ifelse(index, sname, "")
dat$var <- rep(vname, nrow(dat))
ggplot(dat,aes(var,value))+
geom_boxplot()+geom_text(aes(label=label),hjust=-0.1)
}
return(res)
}else{
stop("the value is not conituous data\n")
}
}
checkOutlier(c(1:10,30), sname = paste0("a",1:11), plot = TRUE)
library(ggplot2)
checkOutlier(c(1:10,30), sname = paste0("a",1:11), plot = TRUE)
checkOutlier(c(1:10,30), sname = paste0("a",1:11), plot = TRUE)
x <- c(1:10,30)
sname <- paste0("a",1:11)
coef <- 2
x[is.na(x)] <- median(x, na.rm = T)
quantiles <- quantile(x, probs=c(0.25,0.75), na.rm = T)
IQR <- quantiles[2]-quantiles[1]
index <- x < (quantiles[1]-coef*IQR)|x > (quantiles[2]+coef*IQR)
if(any(index)){
# print the outlier
name <- paste0(sname[index], "_", round(x[index], 2))
res <-  paste(name, collapse = " ")
#return(res)
# print the outlier sample on boxplot
if(plot){
dat <- data.frame(value = x)
dat$label <- ifelse(index, sname, "")
dat$var <- rep(vname, nrow(dat))
ggplot(dat,aes(var,value))+
geom_boxplot()+geom_text(aes(label=label),hjust=-0.1)
}
}
plot <- TRUE
x[is.na(x)] <- median(x, na.rm = T)
quantiles <- quantile(x, probs=c(0.25,0.75), na.rm = T)
IQR <- quantiles[2]-quantiles[1]
index <- x < (quantiles[1]-coef*IQR)|x > (quantiles[2]+coef*IQR)
if(any(index)){
# print the outlier
name <- paste0(sname[index], "_", round(x[index], 2))
res <-  paste(name, collapse = " ")
#return(res)
# print the outlier sample on boxplot
if(plot){
dat <- data.frame(value = x)
dat$label <- ifelse(index, sname, "")
dat$var <- rep(vname, nrow(dat))
ggplot(dat,aes(var,value))+
geom_boxplot()+geom_text(aes(label=label),hjust=-0.1)
}
}
vame <- "test"
x[is.na(x)] <- median(x, na.rm = T)
quantiles <- quantile(x, probs=c(0.25,0.75), na.rm = T)
IQR <- quantiles[2]-quantiles[1]
index <- x < (quantiles[1]-coef*IQR)|x > (quantiles[2]+coef*IQR)
if(any(index)){
# print the outlier
name <- paste0(sname[index], "_", round(x[index], 2))
res <-  paste(name, collapse = " ")
#return(res)
# print the outlier sample on boxplot
if(plot){
dat <- data.frame(value = x)
dat$label <- ifelse(index, sname, "")
dat$var <- rep(vname, nrow(dat))
ggplot(dat,aes(var,value))+
geom_boxplot()+geom_text(aes(label=label),hjust=-0.1)
}}
vname <- "test"
x[is.na(x)] <- median(x, na.rm = T)
quantiles <- quantile(x, probs=c(0.25,0.75), na.rm = T)
IQR <- quantiles[2]-quantiles[1]
index <- x < (quantiles[1]-coef*IQR)|x > (quantiles[2]+coef*IQR)
if(any(index)){
# print the outlier
name <- paste0(sname[index], "_", round(x[index], 2))
res <-  paste(name, collapse = " ")
#return(res)
# print the outlier sample on boxplot
if(plot){
dat <- data.frame(value = x)
dat$label <- ifelse(index, sname, "")
dat$var <- rep(vname, nrow(dat))
ggplot(dat,aes(var,value))+
geom_boxplot()+geom_text(aes(label=label),hjust=-0.1)
}}
checkOutlier <- function(x, coef = 2, sname ,plot = F, vname = "test"){
# whether is a conituous data
if(is.numeric(x) & length(levels(as.factor(x)))>=5){
# get the outlier index
x[is.na(x)] <- median(x, na.rm = T)
quantiles <- quantile(x, probs=c(0.25,0.75), na.rm = T)
IQR <- quantiles[2]-quantiles[1]
index <- x < (quantiles[1]-coef*IQR)|x > (quantiles[2]+coef*IQR)
if(any(index)){
# print the outlier
name <- paste0(sname[index], "_", round(x[index], 2))
res <-  paste(name, collapse = " ")
#return(res)
# print the outlier sample on boxplot
if(plot){
dat <- data.frame(value = x)
dat$label <- ifelse(index, sname, "")
dat$var <- rep(vname, nrow(dat))
ggplot(dat,aes(var,value))+
geom_boxplot()+geom_text(aes(label=label),hjust=-0.1)
}
return(res)
}else{
return(NULL)
}
}else{
stop("the value is not conituous data\n")
}
}
?scale
??lof
library(LOF)
install.packages("LOF")
install.packages("DDoutlier")
pip.dat <- readxl::read_excel("../../result/00.data/bjt2d.REPORT.xlsx",col_names = T)
pip.dat <- readxl::read_excel("../../result/00.data/bjt2d.REPORT.xlsx",col_names = T)
pip.dat <- readxl::read_excel("../../result/00.data/bjt2d.REPORT.xlsx",col_names = T)
head(pip.dat)
pipdata$id
pip.dat$id
pip.dat$coverage
dat.reads.num <- pip.dat[,c("raw.reads","abun_size")]
raw.less20m <- sum(pip.dat$raw.reads<20000000)
abun.less20m <- sum(pip.dat$abun_size<20000000)
dat.reads.num2 <- reshape::melt(dat.reads.num)
dat.reads.num2 <- reshape2::melt(dat.reads.num)
ggplot(dat.reads.num2,aes(value/1e6,color=variable))+
geom_line(stat = "density",size=0.8)+
geom_vline(xintercept = 20,size=1,linetype="dashed")+
scale_x_continuous(breaks = c(0,20,50,100,150))+
theme_classic()+mytheme+
xlab("reads number(M paired)")
ggplot(dat.reads.num2,aes(value/1e6,color=variable))+
geom_line(stat = "density",size=0.8)+
geom_vline(xintercept = 20,size=1,linetype="dashed")+
scale_x_continuous(breaks = c(0,20,50,100,150))+
theme_classic()+
#mytheme+
xlab("reads number(M paired)")
dat.pip.qc <- pip.dat[,ncol(pip.dat)-c(5,3:0)]
dat.pip.qc2 <- dat.pip.qc[order(dat.pip.qc$mapped.reads),]
nm.order <- rownames(dat.pip.qc2)
dat.pip.qc2$sample <- rownames(dat.pip.qc2)
dat.pip.qc2 <- melt(dat.pip.qc2,id.vars = c("coverage","sample"),
variable.name = "stage")
dat.pip.qc <- pip.dat[,ncol(pip.dat)-c(5,3:0)]
dat.pip.qc2 <- dat.pip.qc[order(dat.pip.qc$mapped.reads),]
nm.order <- rownames(dat.pip.qc2)
dat.pip.qc2$sample <- rownames(dat.pip.qc2)
dat.pip.qc2 <- reshape2::melt(dat.pip.qc2,id.vars = c("coverage","sample"),
variable.name = "stage")
dat.pip.qc2$stage <- factor(dat.pip.qc2$stage,
levels = c("lowQ.reads","host.reads","unmapped.reads","mapped.reads"))
dat.pip.qc2$sample <- factor(dat.pip.qc2$sample,levels = nm.order)
dat.pip.qc2$value <- dat.pip.qc2$value/1e6
ggplot(dat.pip.qc2,aes(sample,value,fill=stage))+
geom_bar(stat = "identity")+
geom_hline(yintercept = 20)+
theme_classic()+
mytheme+
theme(axis.text.x = element_blank(),
legend.position = c(0.01,0.99),
legend.justification = c(0,1),
axis.ticks = element_blank())+
xlab("")+ylab("reads number (M)")+
scale_y_continuous(expand = c(0,0),breaks = c(0,20,40,80,120,160))
ggplot(dat.pip.qc2,aes(sample,value,fill=stage))+
geom_bar(stat = "identity")+
geom_hline(yintercept = 20)+
theme_classic()+
#mytheme+
theme(axis.text.x = element_blank(),
legend.position = c(0.01,0.99),
legend.justification = c(0,1),
axis.ticks = element_blank())+
xlab("")+ylab("reads number (M)")+
scale_y_continuous(expand = c(0,0),breaks = c(0,20,40,80,120,160))
pip.dat$id
strsplit(pip.dat$id, split = "-")
unlist(strsplit(pip.dat$id, split = "-"))
unlist(strsplit(pip.dat$id, split = "-"))[2,2*length(pip.dat$id),2]
unlist(strsplit(pip.dat$id, split = "-"))[seq(2,2*length(pip.dat$id),2)]
unlist(strsplit(pip.dat$id, split = "-"))[seq(2,2*length(pip.dat$id),2)] >sampleID
unlist(strsplit(pip.dat$id, split = "-"))[seq(2,2*length(pip.dat$id),2)] -> sampleID
table(sampleID)
table(sampleID)==3
sum(table(sampleID)==3)
sum(table(sampleID)>=2)
sum(table(sampleID)==1)
sort(pip.dat$id)
gsub("A", "", sampleID)
gsub("A", "", sampleID) -> sampleID2
table(sampleID2)
sum(table(sampleID2)==1)
sum(table(sampleID2)>=2)
sum(table(sampleID2)>=3)
sum(table(sampleID2)>3)
library(DDoutlier)
?lof
?LOF
example("LOF")
source('D:/work/github/rmeta-master/R/statMeta.R', echo=TRUE)
library(rmeta)
metadata <- read.table("raw_data/metagenome.species.pro.profile", header = T, row.names = 1, sep = "\t")
metadata <- read.table("raw_data/metagenome.species.pro.profile", header = T, row.names = 1)
metadata <- read.table("raw_data/metagenome.species.pro.profile", header = T, row.names = 1, fill = T)
View(metadata)
sort(apply(metadata ,1 ,sum), decreasing = T)
head(sort(apply(metadata ,1 ,sum), decreasing = T),5)
head(sort(apply(metadata ,1 ,median), decreasing = T),5)
head(sort(apply(metadata ,1 ,mean), decreasing = T),5)
K <- 10
top <- names(head(sort(apply(metadata , 1, median), decreasing = T), K))
topdata <- metadata[top, ]
lessdata <- metadata[-which(rownames(metadata) %in% top), ]
dim(lessdata)
apply(lessdata, 2, sum)
dataframe(apply(lessdata, 2, sum))
data,frame(apply(lessdata, 2, sum))
data.frame(apply(lessdata, 2, sum))
t(data.frame(apply(lessdata, 2, sum)))
metadata[is.na(metadata)] <- 0
rmUnclass <- TURE
rmUnclass <- TRUE
if(rmUnclass){
# rm the unclass & renorm
unclassindex <- which(rownames(metadata) %in% "unclassed")
metadata <- metadata[-unclassindex, ]
metadata <- t(apply(metadata, 2, function(x){y <- x/sum(x); return(y)}))
}
# order the tax
top <- names(head(sort(apply(metadata , 1, median), decreasing = T), K))
topdata <- metadata[top, ]
lessdata <- metadata[-which(rownames(metadata) %in% top), ]
otherdata <- t(data.frame(apply(lessdata, 2, sum)))
rownames(otherdata) <- "Others"
qdat <- rbind(topdata, otherdata)
# plot the result
naOrder <- rownames(qdat)
idOrder <- colnames(qdat)[order(qdat[1,], decreasing = T)]
inOrder
idOrder
dim(qdat)
dim(metadata)
metadata <- read.table("raw_data/metagenome.species.pro.profile", header = T, row.names = 1, fill = T)
dim(metadata)
metadata[is.na(metadata)] <- 0
dim(metadata)
unclassindex <- which(rownames(metadata) %in% "unclassed")
metadata <- metadata[-unclassindex, ]
metadata <- t(apply(metadata, 2, function(x){y <- x/sum(x); return(y)}))
dim(metadata)
metadata <- read.table("raw_data/metagenome.species.pro.profile", header = T, row.names = 1, fill = T)
metadata[is.na(metadata)] <- 0
unclassindex <- which(rownames(metadata) %in% "unclassed")
metadata <- metadata[-unclassindex, ]
metadata <- apply(metadata, 2, function(x){y <- x/sum(x); return(y)})
top <- names(head(sort(apply(metadata , 1, median), decreasing = T), K))
topdata <- metadata[top, ]
lessdata <- metadata[-which(rownames(metadata) %in% top), ]
otherdata <- t(data.frame(apply(lessdata, 2, sum)))
rownames(otherdata) <- "Others"
qdat <- rbind(topdata, otherdata)
# plot the result
naOrder <- rownames(qdat)
idOrder <- colnames(qdat)[order(qdat[1,], decreasing = T)]
head(qdat)[,1:5]
dim(qdat)
naOrder
head(idOrder)
melt(qdat)
tmp <- reshape2::melt(qdat)
head(tmp)
library(reshape2)
tmp <- melt(qdat, value.name = "Abundance")
head(tmp)
tmp <- melt(qdat, value.name = "Abundance")
